<!DOCTYPE html>
<html class="writer-html5" lang="English" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>conda_recipe_manager.parser.recipe_parser &mdash; Conda Recipe Manager 0.2.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=92fd9be5" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />


  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->

        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=6c0f27eb"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
</head>

<body class="wy-body-for-nav">
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >



          <a href="../../../index.html" class="icon icon-home">
            Conda Recipe Manager
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Getting Started/Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer_guide.html">Developer Documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Conda Recipe Manager</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">conda_recipe_manager.parser.recipe_parser</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">

  <h1>Source code for conda_recipe_manager.parser.recipe_parser</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">File:           recipe_parser.py</span>
<span class="sd">Description:    Provides a class that takes text from a Jinja-formatted recipe file and parses it. This allows for easy</span>
<span class="sd">                semantic understanding and manipulation of the file.</span>

<span class="sd">                Patching these files is done using a JSON-patch like syntax. This project closely conforms to the</span>
<span class="sd">                RFC 6902 spec, but deviates in some specific ways to handle the Jinja variables and comments found in</span>
<span class="sd">                conda recipe files.</span>

<span class="sd">                Links:</span>
<span class="sd">                - https://jsonpatch.com/</span>
<span class="sd">                - https://datatracker.ietf.org/doc/html/rfc6902/</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Allows older versions of python to use newer forms of type annotation. There are major features introduced in &gt;=3.9</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">ast</span>
<span class="kn">import</span> <span class="nn">difflib</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Final</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">TypeGuard</span><span class="p">,</span> <span class="n">cast</span><span class="p">,</span> <span class="n">no_type_check</span>

<span class="kn">import</span> <span class="nn">yaml</span>
<span class="kn">from</span> <span class="nn">jsonschema</span> <span class="kn">import</span> <span class="n">validate</span> <span class="k">as</span> <span class="n">schema_validate</span>

<span class="kn">from</span> <span class="nn">conda_recipe_manager.parser._node</span> <span class="kn">import</span> <span class="n">Node</span>
<span class="kn">from</span> <span class="nn">conda_recipe_manager.parser._selector_info</span> <span class="kn">import</span> <span class="n">SelectorInfo</span>
<span class="kn">from</span> <span class="nn">conda_recipe_manager.parser._traverse</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">INVALID_IDX</span><span class="p">,</span>
    <span class="n">remap_child_indices_virt_to_phys</span><span class="p">,</span>
    <span class="n">traverse</span><span class="p">,</span>
    <span class="n">traverse_all</span><span class="p">,</span>
    <span class="n">traverse_with_index</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">conda_recipe_manager.parser._types</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">RECIPE_MANAGER_SUB_MARKER</span><span class="p">,</span>
    <span class="n">ROOT_NODE_VALUE</span><span class="p">,</span>
    <span class="n">ForceIndentDumper</span><span class="p">,</span>
    <span class="n">Regex</span><span class="p">,</span>
    <span class="n">StrStack</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">conda_recipe_manager.parser._utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">dedupe_and_preserve_order</span><span class="p">,</span>
    <span class="n">normalize_multiline_strings</span><span class="p">,</span>
    <span class="n">num_tab_spaces</span><span class="p">,</span>
    <span class="n">quote_special_strings</span><span class="p">,</span>
    <span class="n">stack_path_to_str</span><span class="p">,</span>
    <span class="n">str_to_stack_path</span><span class="p">,</span>
    <span class="n">stringify_yaml</span><span class="p">,</span>
    <span class="n">substitute_markers</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">conda_recipe_manager.parser.enums</span> <span class="kn">import</span> <span class="n">SchemaVersion</span><span class="p">,</span> <span class="n">SelectorConflictMode</span>
<span class="kn">from</span> <span class="nn">conda_recipe_manager.parser.exceptions</span> <span class="kn">import</span> <span class="n">JsonPatchValidationException</span>
<span class="kn">from</span> <span class="nn">conda_recipe_manager.parser.types</span> <span class="kn">import</span> <span class="n">JSON_PATCH_SCHEMA</span><span class="p">,</span> <span class="n">TAB_AS_SPACES</span><span class="p">,</span> <span class="n">TAB_SPACE_COUNT</span><span class="p">,</span> <span class="n">MultilineVariant</span>
<span class="kn">from</span> <span class="nn">conda_recipe_manager.types</span> <span class="kn">import</span> <span class="n">PRIMITIVES_TUPLE</span><span class="p">,</span> <span class="n">JsonPatchType</span><span class="p">,</span> <span class="n">JsonType</span><span class="p">,</span> <span class="n">Primitives</span><span class="p">,</span> <span class="n">SentinelType</span>


<div class="viewcode-block" id="RecipeParser">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser">[docs]</a>
<span class="k">class</span> <span class="nc">RecipeParser</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class that parses a recipe file string. Provides many useful mechanisms for changing values in the document.</span>

<span class="sd">    A quick search for Jinja statements in YAML files shows that the vast majority of statements are in the form of</span>
<span class="sd">    initializing variables with `set`.</span>

<span class="sd">    The next few prevalent kinds of statements are:</span>
<span class="sd">      - Conditional macros (i.e. if/endif)</span>
<span class="sd">      - for loops</span>
<span class="sd">    And even those only show up in a handful out of thousands of recipes. There are also no current examples of Jinja</span>
<span class="sd">    style comments.</span>

<span class="sd">    So that being said, the initial parser will not support these more edge-case recipes as they don&#39;t pass the 80/20</span>
<span class="sd">    rule.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Static set of patch operations that require `from`. The others require `value` or nothing.</span>
    <span class="n">_patch_ops_requiring_from</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="s2">&quot;move&quot;</span><span class="p">])</span>
    <span class="c1"># Sentinel object used for detecting defaulting behavior.</span>
    <span class="c1"># See here for a good explanation: https://peps.python.org/pep-0661/</span>
    <span class="n">_sentinel</span> <span class="o">=</span> <span class="n">SentinelType</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_parse_yaml_recursive_sub</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">JsonType</span><span class="p">,</span> <span class="n">modifier</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="n">JsonType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">JsonType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursive helper function used when we need to perform variable substitutions.</span>
<span class="sd">        :param data: Data to substitute values in</span>
<span class="sd">        :param modifier: Modifier function that performs some kind of substitution.</span>
<span class="sd">        :returns: Pythonic data corresponding to the line of YAML</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Add the substitutions back in</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">modifier</span><span class="p">(</span><span class="n">quote_special_strings</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_parse_yaml_recursive_sub</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]),</span> <span class="n">modifier</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
                <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_parse_yaml_recursive_sub</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">modifier</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_parse_yaml</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">parser</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">RecipeParser</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">JsonType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse a line (or multiple) of YAML into a Pythonic data structure</span>
<span class="sd">        :param s: String to parse</span>
<span class="sd">        :param parser: (Optional) If provided, this will substitute Jinja variables with values specified in in the</span>
<span class="sd">            recipe file. Since `_parse_yaml()` is critical to constructing recipe files, this function must remain</span>
<span class="sd">            static. Also, during construction, we shouldn&#39;t be using a variables until the entire recipe is read/parsed.</span>
<span class="sd">        :returns: Pythonic data corresponding to the line of YAML</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span><span class="p">:</span> <span class="n">JsonType</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># V1 recipes use $-escaped JINJA substitutions that will not throw parse exceptions. If variable substitution</span>
        <span class="c1"># is requested, we will need to handle that directly.</span>
        <span class="k">def</span> <span class="nf">_v1_sub_jinja</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">parser</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">parser</span><span class="o">.</span><span class="n">get_schema_version</span><span class="p">()</span> <span class="o">==</span> <span class="n">SchemaVersion</span><span class="o">.</span><span class="n">V1</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_parse_yaml_recursive_sub</span><span class="p">(</span>
                    <span class="n">output</span><span class="p">,</span> <span class="n">parser</span><span class="o">.</span><span class="n">_render_jinja_vars</span>  <span class="c1"># pylint: disable=protected-access</span>
                <span class="p">)</span>

        <span class="c1"># Our first attempt handles special string cases that require quotes that the YAML parser drops. If that fails,</span>
        <span class="c1"># then we fall back to performing JINJA substitutions.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">JsonType</span><span class="p">,</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
                <span class="n">_v1_sub_jinja</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">yaml</span><span class="o">.</span><span class="n">scanner</span><span class="o">.</span><span class="n">ScannerError</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">JsonType</span><span class="p">,</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">quote_special_strings</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
                <span class="n">_v1_sub_jinja</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>  <span class="c1"># pylint: disable=broad-exception-caught</span>
            <span class="c1"># If a construction exception is thrown, attempt to re-parse by replacing Jinja macros (substrings in</span>
            <span class="c1"># `{{}}`) with friendly string substitution markers, then re-inject the substitutions back in. We classify</span>
            <span class="c1"># all Jinja substitutions as string values, so we don&#39;t have to worry about the type of the actual</span>
            <span class="c1"># substitution.</span>
            <span class="n">sub_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">Regex</span><span class="o">.</span><span class="n">JINJA_V0_SUB</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">Regex</span><span class="o">.</span><span class="n">JINJA_V0_SUB</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">RECIPE_MANAGER_SUB_MARKER</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_parse_yaml_recursive_sub</span><span class="p">(</span>
                <span class="n">cast</span><span class="p">(</span><span class="n">JsonType</span><span class="p">,</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">s</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">substitute_markers</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">sub_list</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># Because we leverage PyYaml to parse the data structures, we need to perform a second pass to perform</span>
            <span class="c1"># variable substitutions.</span>
            <span class="k">if</span> <span class="n">parser</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_parse_yaml_recursive_sub</span><span class="p">(</span>
                    <span class="n">output</span><span class="p">,</span> <span class="n">parser</span><span class="o">.</span><span class="n">_render_jinja_vars</span>  <span class="c1"># pylint: disable=protected-access</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_parse_line_node</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parses a line of conda-formatted YAML into a Node.</span>

<span class="sd">        Latest YAML spec can be found here: https://yaml.org/spec/1.2.2/</span>

<span class="sd">        :param s: Pre-stripped (no leading/trailing spaces), non-Jinja line of a recipe file</span>
<span class="sd">        :returns: A Node representing a line of the conda-formatted YAML.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use PyYaml to safely/easily/correctly parse single lines of YAML.</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_parse_yaml</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="c1"># Attempt to parse-out comments. Fully commented lines are not ignored to preserve context when the text is</span>
        <span class="c1"># rendered. Their order in the list of child nodes will preserve their location. Fully commented lines just have</span>
        <span class="c1"># a value of &quot;None&quot;.</span>
        <span class="c1">#</span>
        <span class="c1"># There is an open issue to PyYaml to support comment parsing:</span>
        <span class="c1">#   - https://github.com/yaml/pyyaml/issues/90</span>
        <span class="n">comment</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="c1"># The full line is a comment</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="n">comment</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
        <span class="c1"># There is a comment at the end of the line if a `#` symbol is found with leading whitespace before it. If it is</span>
        <span class="c1"># &quot;touching&quot; a character on the left-side, it is just part of a string.</span>
        <span class="n">comment_re_result</span> <span class="o">=</span> <span class="n">Regex</span><span class="o">.</span><span class="n">DETECT_TRAILING_COMMENT</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">comment_re_result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Group 0 is the whole match, Group 1 is the leading whitespace, Group 2 locates the `#`</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">comment_re_result</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">:]</span>

        <span class="c1"># If a dictionary is returned, we have a line containing a key and potentially a value. There should only be 1</span>
        <span class="c1"># key/value pairing in 1 line. Nodes representing keys should be flagged for handling edge cases.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">children</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># If the value returned is None, there is no leaf node to set</span>
            <span class="k">if</span> <span class="n">output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># As the line is shared by both parent and child, the comment gets tagged to both.</span>
                <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">Primitives</span><span class="p">,</span> <span class="n">output</span><span class="p">[</span><span class="n">key</span><span class="p">]),</span> <span class="n">comment</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">comment</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">key_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># If a list is returned, then this line is a listed member of the parent Node</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># The full line is a comment</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">):</span>
                <span class="c1"># Comments are list members to ensure indentation</span>
                <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="n">comment</span><span class="o">=</span><span class="n">comment</span><span class="p">,</span> <span class="n">list_member_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Special scenarios that can occur on 1 line:</span>
            <span class="c1">#   1. Lists can contain lists: - - foo -&gt; [[&quot;foo&quot;]]</span>
            <span class="c1">#   2. Lists can contain keys:  - foo: bar -&gt; [{&quot;foo&quot;: &quot;bar&quot;}]</span>
            <span class="c1"># And, of course, there can be n values in each of these collections on 1 line as well. Scenario 2 occurs in</span>
            <span class="c1"># multi-output recipe files so we need to support the scenario here.</span>
            <span class="c1">#</span>
            <span class="c1"># `PKG-3006` tracks an investigation effort into what we need to support for our purposes.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="c1"># Build up the key-and-potentially-value pair nodes first</span>
                <span class="n">key_children</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">key_children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">Primitives</span><span class="p">,</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">key</span><span class="p">]),</span> <span class="n">comment</span><span class="p">))</span>
                <span class="n">key_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">comment</span><span class="p">,</span> <span class="n">key_children</span><span class="p">,</span> <span class="n">key_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">elem_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">comment</span><span class="o">=</span><span class="n">comment</span><span class="p">,</span> <span class="n">list_member_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">elem_node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key_node</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">elem_node</span>
            <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">Primitives</span><span class="p">,</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">comment</span><span class="p">,</span> <span class="n">list_member_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Other types are just leaf nodes. This is scenario should likely not be triggered given our recipe files don&#39;t</span>
        <span class="c1"># have single valid lines of YAML, but we cover this case for the sake of correctness.</span>
        <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">comment</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_generate_subtree</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">JsonType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Node</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a value supported by JSON, use the RecipeParser to generate a list of child nodes. This effectively</span>
<span class="sd">        creates a new subtree that can be used to patch other parse trees.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Multiline values can replace the list of children with a single multiline leaf node.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">Node</span><span class="p">(</span>
                    <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(),</span>
                    <span class="c1"># The conversion from JSON-to-YAML is lossy here. Default to the closest equivalent, which preserves</span>
                    <span class="c1"># newlines.</span>
                    <span class="n">multiline_variant</span><span class="o">=</span><span class="n">MultilineVariant</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">]</span>

        <span class="c1"># For complex types, generate the YAML equivalent and build a new tree.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">PRIMITIVES_TUPLE</span><span class="p">):</span>
            <span class="c1"># Although not technically required by YAML, we add the optional spacing for human readability.</span>
            <span class="k">return</span> <span class="n">RecipeParser</span><span class="p">(</span>  <span class="c1"># pylint: disable=protected-access</span>
                <span class="c1"># NOTE: `yaml.dump()` defaults to 80 character lines. Longer lines may have newlines unexpectedly</span>
                <span class="c1">#       injected into this value, screwing up the parse-tree.</span>
                <span class="n">yaml</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Dumper</span><span class="o">=</span><span class="n">ForceIndentDumper</span><span class="p">,</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">)</span>  <span class="c1"># type: ignore[misc]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">_root</span><span class="o">.</span><span class="n">children</span>

        <span class="c1"># Primitives can be safely stringified to generate a parse tree.</span>
        <span class="k">return</span> <span class="n">RecipeParser</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">stringify_yaml</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span><span class="o">.</span><span class="n">_root</span><span class="o">.</span><span class="n">children</span>  <span class="c1"># pylint: disable=protected-access</span>

    <span class="k">def</span> <span class="nf">_render_jinja_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">JsonType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function that replaces Jinja substitutions with their actual set values.</span>
<span class="sd">        :param s: String to be re-rendered</span>
<span class="sd">        :returns: The original value, augmented with Jinja substitutions. Types are re-rendered to account for multiline</span>
<span class="sd">            strings that may have been &quot;normalized&quot; prior to this call.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Initialize `schema_version` specific details.</span>
        <span class="k">def</span> <span class="nf">_set_on_schema_version</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
            <span class="k">match</span> <span class="bp">self</span><span class="o">.</span><span class="n">_schema_version</span><span class="p">:</span>
                <span class="k">case</span> <span class="n">SchemaVersion</span><span class="o">.</span><span class="n">V0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">2</span><span class="p">,</span> <span class="n">Regex</span><span class="o">.</span><span class="n">JINJA_V0_SUB</span>
                <span class="k">case</span> <span class="n">SchemaVersion</span><span class="o">.</span><span class="n">V1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">3</span><span class="p">,</span> <span class="n">Regex</span><span class="o">.</span><span class="n">JINJA_V1_SUB</span>

        <span class="n">start_idx</span><span class="p">,</span> <span class="n">sub_regex</span> <span class="o">=</span> <span class="n">_set_on_schema_version</span><span class="p">()</span>

        <span class="c1"># Search the string, replacing all substitutions we can recognize</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">cast</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">sub_regex</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="c1"># The regex guarantees the string starts and ends with double braces</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="c1"># Check for and interpret common JINJA functions</span>
            <span class="c1"># TODO add support for UPPER and REPLACE</span>
            <span class="n">lower_match</span> <span class="o">=</span> <span class="n">Regex</span><span class="o">.</span><span class="n">JINJA_FUNCTION_LOWER</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lower_match</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">lower_match</span><span class="o">.</span><span class="n">group</span><span class="p">(),</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars_tbl</span><span class="p">:</span>
                <span class="c1"># Replace value as a string. Re-interpret the entire value before returning.</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vars_tbl</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">lower_match</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">JsonType</span><span class="p">,</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_init_vars_tbl</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the variable table, `vars_tbl` based on the document content.</span>
<span class="sd">        Requires parse-tree and `_schema_version` to be initialized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Tracks Jinja variables set by the file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vars_tbl</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">JsonType</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">match</span> <span class="bp">self</span><span class="o">.</span><span class="n">_schema_version</span><span class="p">:</span>
            <span class="k">case</span> <span class="n">SchemaVersion</span><span class="o">.</span><span class="n">V0</span><span class="p">:</span>
                <span class="c1"># Find all the set statements and record the values</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">cast</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Regex</span><span class="o">.</span><span class="n">JINJA_V0_SET_LINE</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_content</span><span class="p">)):</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;set&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="s2">&quot;set&quot;</span><span class="p">)</span> <span class="p">:</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span> <span class="p">:</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;%}&quot;</span><span class="p">)]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_vars_tbl</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>  <span class="c1"># type: ignore[misc]</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>  <span class="c1"># pylint: disable=broad-exception-caught</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_vars_tbl</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">case</span> <span class="n">SchemaVersion</span><span class="o">.</span><span class="n">V1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_vars_tbl</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">JsonType</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;/context&quot;</span><span class="p">,</span> <span class="p">{}))</span>

    <span class="k">def</span> <span class="nf">_rebuild_selectors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Re-builds the selector look-up table. This table allows quick access to tree nodes that have a selector</span>
<span class="sd">        specified. This needs to be called when the tree or selectors are modified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_selector_tbl</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">SelectorInfo</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">_collect_selectors</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">StrStack</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Ignore empty comments</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">comment</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">Regex</span><span class="o">.</span><span class="n">SELECTOR</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">comment</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">selector</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">selector_info</span> <span class="o">=</span> <span class="n">SelectorInfo</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_selector_tbl</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">selector</span><span class="p">,</span> <span class="p">[])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_selector_tbl</span><span class="p">[</span><span class="n">selector</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">selector_info</span><span class="p">)</span>

        <span class="n">traverse_all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">,</span> <span class="n">_collect_selectors</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># pylint: disable=too-complex</span>
        <span class="c1"># TODO Refactor and simplify ^</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs a RecipeParser instance.</span>
<span class="sd">        :param content: conda-build formatted recipe file, as a single text string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The initial, raw, text is preserved for diffing and debugging purposes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_content</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">content</span>
        <span class="c1"># Indicates if the original content has changed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_modified</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Root of the parse tree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">ROOT_NODE_VALUE</span><span class="p">)</span>
        <span class="c1"># Start by removing all Jinja lines. Then traverse line-by-line</span>
        <span class="n">sanitized_yaml</span> <span class="o">=</span> <span class="n">Regex</span><span class="o">.</span><span class="n">JINJA_V0_LINE</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_content</span><span class="p">)</span>

        <span class="c1"># Read the YAML line-by-line, maintaining a stack to manage the last owning node in the tree.</span>
        <span class="n">node_stack</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">]</span>
        <span class="c1"># Relative depth is determined by the increase/decrease of indentation marks (spaces)</span>
        <span class="n">cur_indent</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">last_node</span> <span class="o">=</span> <span class="n">node_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Iterate with an index variable, so we can handle multiline values</span>
        <span class="n">line_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">sanitized_yaml</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
        <span class="n">num_lines</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">line_idx</span> <span class="o">&lt;</span> <span class="n">num_lines</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">line_idx</span><span class="p">]</span>
            <span class="c1"># Increment here, so that the inner multiline processing loop doesn&#39;t cause a skip of the line following the</span>
            <span class="c1"># multiline value.</span>
            <span class="n">line_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Ignore empty lines</span>
            <span class="n">clean_line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">clean_line</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">new_indent</span> <span class="o">=</span> <span class="n">num_tab_spaces</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_parse_line_node</span><span class="p">(</span><span class="n">clean_line</span><span class="p">)</span>
            <span class="c1"># If the last node ended (pre-comments) with a |, &gt;, or other multi-line character, reset the value to be a</span>
            <span class="c1"># list of the following extra-indented strings</span>
            <span class="n">multiline_re_match</span> <span class="o">=</span> <span class="n">Regex</span><span class="o">.</span><span class="n">MULTILINE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">multiline_re_match</span><span class="p">:</span>
                <span class="c1"># Calculate which multiline symbol is used. The first character must be matched, the second is optional.</span>
                <span class="n">variant_capture</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">multiline_re_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">Regex</span><span class="o">.</span><span class="n">MULTILINE_VARIANT_CAPTURE_GROUP_CHAR</span><span class="p">))</span>
                <span class="n">variant_sign</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">multiline_re_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">Regex</span><span class="o">.</span><span class="n">MULTILINE_VARIANT_CAPTURE_GROUP_SUFFIX</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">variant_sign</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">variant_capture</span> <span class="o">+=</span> <span class="n">variant_sign</span>
                <span class="c1"># Per YAML spec, multiline statements can&#39;t be commented. In other words, the `#` symbol is seen as a</span>
                <span class="c1"># string character in multiline values.</span>
                <span class="n">multiline_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span>
                    <span class="p">[],</span>
                    <span class="n">multiline_variant</span><span class="o">=</span><span class="n">MultilineVariant</span><span class="p">(</span><span class="n">variant_capture</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="c1"># Type narrow that we assigned `value` as a `list`</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">multiline_node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
                <span class="n">multiline</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">line_idx</span><span class="p">]</span>
                <span class="n">multiline_indent</span> <span class="o">=</span> <span class="n">num_tab_spaces</span><span class="p">(</span><span class="n">multiline</span><span class="p">)</span>
                <span class="c1"># Add the line to the list once it is verified to be the next line to capture in this node. This means</span>
                <span class="c1"># that `line_idx` will point to the line of the next node, post-processing. Note that blank lines are</span>
                <span class="c1"># valid in multi-line strings, occasionally found in `/about/summary` sections.</span>
                <span class="k">while</span> <span class="n">multiline_indent</span> <span class="o">&gt;</span> <span class="n">new_indent</span> <span class="ow">or</span> <span class="n">multiline</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                    <span class="n">multiline_node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">multiline</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
                    <span class="n">line_idx</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">multiline</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">line_idx</span><span class="p">]</span>
                    <span class="n">multiline_indent</span> <span class="o">=</span> <span class="n">num_tab_spaces</span><span class="p">(</span><span class="n">multiline</span><span class="p">)</span>
                <span class="c1"># The previous level is the key to this multi-line value, so we can safely reset it.</span>
                <span class="n">new_node</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="n">multiline_node</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">new_indent</span> <span class="o">&gt;</span> <span class="n">cur_indent</span><span class="p">:</span>
                <span class="n">node_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_node</span><span class="p">)</span>
                <span class="c1"># Edge case: The first element of a list of objects that is NOT a 1-line key-value pair needs</span>
                <span class="c1"># to be added to the stack to maintain composition</span>
                <span class="k">if</span> <span class="n">last_node</span><span class="o">.</span><span class="n">is_collection_element</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">last_node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_single_key</span><span class="p">():</span>
                    <span class="n">node_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">new_indent</span> <span class="o">&lt;</span> <span class="n">cur_indent</span><span class="p">:</span>
                <span class="c1"># Multiple levels of depth can change from line to line, so multiple stack nodes must be pop&#39;d. Example:</span>
                <span class="c1"># foo:</span>
                <span class="c1">#   bar:</span>
                <span class="c1">#     fizz: buzz</span>
                <span class="c1"># baz: blah</span>
                <span class="c1"># TODO Figure out tab-depth of the recipe being read. 4 spaces is technically valid in YAML</span>
                <span class="n">depth_to_pop</span> <span class="o">=</span> <span class="p">(</span><span class="n">cur_indent</span> <span class="o">-</span> <span class="n">new_indent</span><span class="p">)</span> <span class="o">//</span> <span class="n">TAB_SPACE_COUNT</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">depth_to_pop</span><span class="p">):</span>
                    <span class="n">node_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">cur_indent</span> <span class="o">=</span> <span class="n">new_indent</span>
            <span class="c1"># Look at the stack to determine the parent Node and then append the current node to the new parent.</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">node_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>
            <span class="c1"># Update the last node for the next line interpretation</span>
            <span class="n">last_node</span> <span class="o">=</span> <span class="n">new_node</span>

        <span class="c1"># Auto-detect and deserialize the version of the recipe schema. This will change how the class behaves.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_schema_version</span> <span class="o">=</span> <span class="n">SchemaVersion</span><span class="o">.</span><span class="n">V0</span>
        <span class="n">schema_version</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">SchemaVersion</span> <span class="o">|</span> <span class="nb">int</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;/schema_version&quot;</span><span class="p">,</span> <span class="n">SchemaVersion</span><span class="o">.</span><span class="n">V0</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">schema_version</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">schema_version</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_schema_version</span> <span class="o">=</span> <span class="n">SchemaVersion</span><span class="o">.</span><span class="n">V1</span>

        <span class="c1"># Initialize the variables table. This behavior changes per `schema_version`</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_vars_tbl</span><span class="p">()</span>

        <span class="c1"># Now that the tree is built, construct a selector look-up table that tracks all the nodes that use a particular</span>
        <span class="c1"># selector. This will make it easier to.</span>
        <span class="c1">#</span>
        <span class="c1"># This table will have to be re-built or modified when the tree is modified with `patch()`.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rebuild_selectors</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_canonical_sort_keys_comparison</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">priority_tbl</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a look-up table defining &quot;canonical&quot; sort order, this function provides a way to compare Nodes.</span>
<span class="sd">        :param n: Node to evaluate</span>
<span class="sd">        :param priority_tbl: Table that provides a &quot;canonical ordering&quot; of keys</span>
<span class="sd">        :returns: An integer indicating sort-order priority</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For now, put all comments at the top of the section. Arguably this is better than having them &quot;randomly tag&quot;</span>
        <span class="c1"># to another top-level key.</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">is_comment</span><span class="p">():</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span>
        <span class="c1"># Unidentified keys go to the bottom of the section.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">priority_tbl</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span>
        <span class="k">return</span> <span class="n">priority_tbl</span><span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_str_tree_recurse</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">lines</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function that renders a parse tree as a text-based dependency tree. Useful for debugging.</span>
<span class="sd">        :param node: Node of interest</span>
<span class="sd">        :param depth: Current depth of the node</span>
<span class="sd">        :param lines: Accumulated list of lines to text to render</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spaces</span> <span class="o">=</span> <span class="n">TAB_AS_SPACES</span> <span class="o">*</span> <span class="n">depth</span>
        <span class="n">branch</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;|- &quot;</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">spaces</span><span class="si">}{</span><span class="n">branch</span><span class="si">}{</span><span class="n">node</span><span class="o">.</span><span class="n">short_str</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_str_tree_recurse</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lines</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Casts the parser into a string. Useful for debugging.</span>
<span class="sd">        :returns: String representation of the recipe file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;--------------------</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">tree_lines</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_str_tree_recurse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tree_lines</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;RecipeParser Instance</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;- Schema Version: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_schema_version</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;- Variables Table:</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vars_tbl</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="n">TAB_AS_SPACES</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;- Selectors Table:</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selector_tbl</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">TAB_AS_SPACES</span><span class="si">}{</span><span class="n">key</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">TAB_AS_SPACES</span><span class="si">}{</span><span class="n">TAB_AS_SPACES</span><span class="si">}</span><span class="s2">- </span><span class="si">{</span><span class="n">info</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;- is_modified?: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_modified</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;- Tree:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tree_lines</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;--------------------</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if two recipe representations match entirely</span>
<span class="sd">        :param other: Other recipe parser instance to check against.</span>
<span class="sd">        :returns: True if both recipes contain the same current state. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">RecipeParser</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_schema_version</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_schema_version</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">render</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">render</span><span class="p">()</span>

<div class="viewcode-block" id="RecipeParser.is_modified">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.is_modified">[docs]</a>
    <span class="k">def</span> <span class="nf">is_modified</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicates if the recipe has been changed since construction.</span>
<span class="sd">        :returns: True if the recipe has changed. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_modified</span></div>


<div class="viewcode-block" id="RecipeParser.get_schema_version">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.get_schema_version">[docs]</a>
    <span class="k">def</span> <span class="nf">get_schema_version</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SchemaVersion</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns which version of the schema this recipe uses. Useful for preventing illegal operations.</span>
<span class="sd">        :returns: Schema Version of the recipe file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_schema_version</span></div>


<div class="viewcode-block" id="RecipeParser.has_unsupported_statements">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.has_unsupported_statements">[docs]</a>
    <span class="k">def</span> <span class="nf">has_unsupported_statements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs a series of checks against the original recipe file.</span>
<span class="sd">        :returns: True if the recipe has statements we do not currently support. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO complete</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_render_tree</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">lines</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># pylint: disable=too-complex</span>
        <span class="c1"># TODO Refactor and simplify ^</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursive helper function that traverses the parse tree to generate a file.</span>
<span class="sd">        :param node: Current node in the tree</span>
<span class="sd">        :param depth: Current depth of the recursion</span>
<span class="sd">        :param lines: Accumulated list of lines in the recipe file</span>
<span class="sd">        :param parent: (Optional) Parent node to the current node. Set by recursive calls only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spaces</span> <span class="o">=</span> <span class="n">TAB_AS_SPACES</span> <span class="o">*</span> <span class="n">depth</span>

        <span class="c1"># Edge case: The first element of dictionary in a list has a list `- ` prefix. Subsequent keys in the dictionary</span>
        <span class="c1"># just have a tab.</span>
        <span class="n">is_first_collection_child</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">parent</span><span class="o">.</span><span class="n">is_collection_element</span><span class="p">()</span> <span class="ow">and</span> <span class="n">node</span> <span class="o">==</span> <span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Handle same-line printing</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_single_key</span><span class="p">():</span>
            <span class="c1"># Edge case: Handle a list containing 1 member</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">list_member_flag</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_first_collection_child</span><span class="p">:</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">TAB_AS_SPACES</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s2">- </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">:  </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">comment</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">spaces</span><span class="si">}{</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">:  </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">comment</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">())</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">spaces</span><span class="si">}{</span><span class="n">TAB_AS_SPACES</span><span class="si">}</span><span class="s2">- &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">stringify_yaml</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">multiline_variant</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">multiline_variant</span><span class="p">)</span><span class="si">}</span><span class="s2">  &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">comment</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="n">is_first_collection_child</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">TAB_AS_SPACES</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s2">- </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">stringify_yaml</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">  &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">comment</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="k">return</span>

            <span class="c1"># Handle multi-line statements. In theory this will probably only ever be strings, but we&#39;ll try to account</span>
            <span class="c1"># for other types.</span>
            <span class="c1">#</span>
            <span class="c1"># By the language spec, # symbols do not indicate comments on multiline strings.</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">multiline_variant</span> <span class="o">!=</span> <span class="n">MultilineVariant</span><span class="o">.</span><span class="n">NONE</span><span class="p">:</span>
                <span class="n">multi_variant</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="n">MultilineVariant</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">multiline_variant</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">spaces</span><span class="si">}{</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">multi_variant</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">comment</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">val_line</span> <span class="ow">in</span> <span class="n">cast</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">spaces</span><span class="si">}{</span><span class="n">TAB_AS_SPACES</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">stringify_yaml</span><span class="p">(</span><span class="n">val_line</span><span class="p">,</span><span class="w"> </span><span class="n">multiline_variant</span><span class="o">=</span><span class="n">multi_variant</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
                    <span class="p">)</span>
                <span class="k">return</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">spaces</span><span class="si">}{</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">stringify_yaml</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">  &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">comment</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="n">depth_delta</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Don&#39;t render a `:` for the non-visible root node. Also don&#39;t render invisible collection nodes.</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_collection_element</span><span class="p">():</span>
            <span class="n">list_prefix</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="c1"># Creating a copy of `spaces` scoped to this check prevents a scenario in which child nodes of this</span>
            <span class="c1"># collection element are missing one indent-level. The indent now only applies to the collection element.</span>
            <span class="c1"># Example:</span>
            <span class="c1">#   - script:</span>
            <span class="c1">#     - foo  # Incorrect</span>
            <span class="c1">#       - foo  # Correct</span>
            <span class="n">tmp_spaces</span> <span class="o">=</span> <span class="n">spaces</span>
            <span class="c1"># Handle special cases for the &quot;parent&quot; key</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">list_member_flag</span><span class="p">:</span>
                <span class="n">list_prefix</span> <span class="o">=</span> <span class="s2">&quot;- &quot;</span>
                <span class="n">depth_delta</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">is_first_collection_child</span><span class="p">:</span>
                <span class="n">list_prefix</span> <span class="o">=</span> <span class="s2">&quot;- &quot;</span>
                <span class="n">tmp_spaces</span> <span class="o">=</span> <span class="n">tmp_spaces</span><span class="p">[</span><span class="n">TAB_SPACE_COUNT</span><span class="p">:]</span>
            <span class="c1"># Nodes representing collections in a list have nothing to render</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tmp_spaces</span><span class="si">}{</span><span class="n">list_prefix</span><span class="si">}{</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">:  </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">comment</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="c1"># Top-level empty-key edge case: Top level keys should have no additional indentation.</span>
            <span class="n">extra_tab</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">depth</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">TAB_AS_SPACES</span>
            <span class="c1"># Comments in a list are indented to list-level, but do not include a list `-` mark</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">is_comment</span><span class="p">():</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">spaces</span><span class="si">}{</span><span class="n">extra_tab</span><span class="si">}</span><span class="s2">&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">child</span><span class="o">.</span><span class="n">comment</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">())</span>
            <span class="c1"># Empty keys can be easily confused for leaf nodes. The difference is these nodes render with a &quot;dangling&quot;</span>
            <span class="c1"># `:` mark</span>
            <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">is_empty_key</span><span class="p">():</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">spaces</span><span class="si">}{</span><span class="n">extra_tab</span><span class="si">}</span><span class="s2">&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">stringify_yaml</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">:  &quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">child</span><span class="o">.</span><span class="n">comment</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">())</span>
            <span class="c1"># Leaf nodes are rendered as members in a list</span>
            <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">spaces</span><span class="si">}{</span><span class="n">extra_tab</span><span class="si">}</span><span class="s2">- &quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">stringify_yaml</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">  &quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">child</span><span class="o">.</span><span class="n">comment</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_render_tree</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="n">depth_delta</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
            <span class="c1"># By tradition, recipes have a blank line after every top-level section, unless they are a comment. Comments</span>
            <span class="c1"># should be left where they are.</span>
            <span class="k">if</span> <span class="n">depth</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">child</span><span class="o">.</span><span class="n">is_comment</span><span class="p">():</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="RecipeParser.render">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.render">[docs]</a>
    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes the current state of the parse tree and returns the recipe file as a string.</span>
<span class="sd">        :returns: String representation of the recipe file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Render variable set section for V0 recipes. V1 recipes have variables stored in the parse tree under</span>
        <span class="c1"># `/context`.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_schema_version</span> <span class="o">==</span> <span class="n">SchemaVersion</span><span class="o">.</span><span class="n">V0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars_tbl</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># Double quote strings</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s1">&quot;&#39;</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">{{</span><span class="s2">% set </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2"> %</span><span class="se">}}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Add spacing if variables have been set</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vars_tbl</span><span class="p">):</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="c1"># Render parse-tree, -1 is passed in as the &quot;root-level&quot; is not directly rendered in a YAML file; it is merely</span>
        <span class="c1"># implied.</span>
        <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_render_tree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">lines</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>


    <span class="nd">@no_type_check</span>
    <span class="k">def</span> <span class="nf">_render_object_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">replace_variables</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">JsonType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># pylint: disable=too-complex</span>
        <span class="c1"># TODO Refactor and simplify ^</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursive helper function that traverses the parse tree to generate a Pythonic data object.</span>
<span class="sd">        :param node: Current node in the tree</span>
<span class="sd">        :param replace_variables: If set to True, this replaces all variable substitutions with their set values.</span>
<span class="sd">        :param data: Accumulated data structure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ignore comment-only lines</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_comment</span><span class="p">():</span>
            <span class="k">return</span>

        <span class="n">key</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="c1"># Ignore comment-only lines</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">is_comment</span><span class="p">():</span>
                <span class="k">continue</span>

            <span class="c1"># Handle multiline strings and variable replacement</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">normalize_multiline_strings</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">multiline_variant</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">replace_variables</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_render_jinja_vars</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">multiline_variant</span> <span class="o">!=</span> <span class="n">MultilineVariant</span><span class="o">.</span><span class="n">NONE</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

            <span class="c1"># Empty keys are interpreted to point to `None`</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">is_empty_key</span><span class="p">():</span>
                <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">child</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">continue</span>

            <span class="c1"># Collection nodes are skipped as they are placeholders. However, their children are rendered recursively</span>
            <span class="c1"># and added to a list.</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">is_collection_element</span><span class="p">():</span>
                <span class="n">elem_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_render_object_tree</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">replace_variables</span><span class="p">,</span> <span class="n">elem_dict</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem_dict</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># List members accumulate values in a list</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">list_member_flag</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Other (non list and non-empty-key) leaf nodes set values directly</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">continue</span>

            <span class="c1"># All other keys prep for containing more dictionaries</span>
            <span class="n">data</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">{})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_render_object_tree</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">replace_variables</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

<div class="viewcode-block" id="RecipeParser.render_to_object">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.render_to_object">[docs]</a>
    <span class="k">def</span> <span class="nf">render_to_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replace_variables</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">JsonType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes the underlying state of the parse tree and produces a Pythonic object/dictionary representation. Analogous</span>
<span class="sd">        to `json.load()`.</span>
<span class="sd">        :param replace_variables: (Optional) If set to True, this replaces all variable substitutions with their set</span>
<span class="sd">            values.</span>
<span class="sd">        :returns: Pythonic data object representation of the recipe.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">JsonType</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Type narrow after assignment</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>

        <span class="c1"># Bootstrap/flatten the root-level</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">is_comment</span><span class="p">():</span>
                <span class="k">continue</span>
            <span class="n">data</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="p">{})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_render_object_tree</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">replace_variables</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span></div>


    <span class="c1">## YAML Access Functions ##</span>

<div class="viewcode-block" id="RecipeParser.list_value_paths">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.list_value_paths">[docs]</a>
    <span class="k">def</span> <span class="nf">list_value_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides a list of all known terminal paths. This can be used by the caller to perform search operations.</span>
<span class="sd">        :returns: List of all terminal paths in the parse tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lst</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">_find_paths</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">path_stack</span><span class="p">:</span> <span class="n">StrStack</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stack_path_to_str</span><span class="p">(</span><span class="n">path_stack</span><span class="p">))</span>

        <span class="n">traverse_all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">,</span> <span class="n">_find_paths</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lst</span></div>


<div class="viewcode-block" id="RecipeParser.contains_value">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.contains_value">[docs]</a>
    <span class="k">def</span> <span class="nf">contains_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if a value (via a path) is contained in this recipe. This also allows the caller to determine if a</span>
<span class="sd">        path exists.</span>
<span class="sd">        :param path: JSON patch (RFC 6902)-style path to a value.</span>
<span class="sd">        :returns: True if the path exists. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path_stack</span> <span class="o">=</span> <span class="n">str_to_stack_path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">,</span> <span class="n">path_stack</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="RecipeParser.get_value">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.get_value">[docs]</a>
    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="n">JsonType</span> <span class="o">|</span> <span class="n">SentinelType</span> <span class="o">=</span> <span class="n">_sentinel</span><span class="p">,</span> <span class="n">sub_vars</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">JsonType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves a value at a given path. If the value is not found, return a specified default value or throw.</span>
<span class="sd">        TODO Refactor: This function could leverage `render_to_object()` to simplify/de-dupe the logic.</span>
<span class="sd">        :param path: JSON patch (RFC 6902)-style path to a value.</span>
<span class="sd">        :param default: (Optional) If the value is not found, return this value instead.</span>
<span class="sd">        :param sub_vars: (Optional) If set to True and the value contains a Jinja template variable, the Jinja value</span>
<span class="sd">            will be &quot;rendered&quot;.</span>
<span class="sd">        :raises KeyError: If the value is not found AND no default is specified</span>
<span class="sd">        :returns: If found, the value in the recipe at that path. Otherwise, the caller-specified default value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path_stack</span> <span class="o">=</span> <span class="n">str_to_stack_path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">,</span> <span class="n">path_stack</span><span class="p">)</span>

        <span class="c1"># Handle if the path was not found</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">default</span> <span class="o">==</span> <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_sentinel</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="n">SentinelType</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No value/key found at path </span><span class="si">{</span><span class="n">path</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">default</span>

        <span class="n">return_value</span><span class="p">:</span> <span class="n">JsonType</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Handle unpacking of the last key-value set of nodes.</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_single_key</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_root</span><span class="p">():</span>
            <span class="c1"># As of writing, Jinja substitutions are not used</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">multiline_variant</span> <span class="o">!=</span> <span class="n">MultilineVariant</span><span class="o">.</span><span class="n">NONE</span><span class="p">:</span>
                <span class="n">multiline_str</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">,</span>
                    <span class="n">normalize_multiline_strings</span><span class="p">(</span>
                        <span class="n">cast</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">multiline_variant</span>
                    <span class="p">),</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">sub_vars</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_render_jinja_vars</span><span class="p">(</span><span class="n">multiline_str</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">JsonType</span><span class="p">,</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">multiline_str</span><span class="p">))</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Primitives</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="c1"># Leaf nodes can return their value directly</span>
        <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Primitives</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># NOTE: Traversing the tree and generating our own data structures will be more efficient than rendering and</span>
            <span class="c1"># leveraging the YAML parser, BUT this method re-uses code and is easier to maintain.</span>
            <span class="n">lst</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_render_tree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">lst</span><span class="p">)</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>

        <span class="c1"># Collection types are transformed into strings above and will need to be transformed into a proper data type.</span>
        <span class="c1"># `_parse_yaml()` will also render JINJA variables for us, if requested.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">return_value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">parser</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">sub_vars</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">parsed_value</span> <span class="o">=</span> <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_parse_yaml</span><span class="p">(</span><span class="n">return_value</span><span class="p">,</span> <span class="n">parser</span><span class="p">)</span>
            <span class="c1"># Lists containing 1 value will drop the surrounding list by the YAML parser. To ensure greater consistency</span>
            <span class="c1"># and provide better type-safety, we will re-wrap such values.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parsed_value</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">list_member_flag</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">parsed_value</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">parsed_value</span>
        <span class="k">return</span> <span class="n">return_value</span></div>


<div class="viewcode-block" id="RecipeParser.find_value">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.find_value">[docs]</a>
    <span class="k">def</span> <span class="nf">find_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Primitives</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a value, find all the paths that contain that value.</span>

<span class="sd">        NOTE: This only supports searching for &quot;primitive&quot; values, i.e. you cannot search for collections.</span>

<span class="sd">        :param value: Value to find in the recipe.</span>
<span class="sd">        :raises ValueError: If the value provided is not a primitive type.</span>
<span class="sd">        :returns: List of paths where the value can be found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">PRIMITIVES_TUPLE</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;A non-primitive value was provided: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">paths</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">_find_value_paths</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">path_stack</span><span class="p">:</span> <span class="n">StrStack</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Special cases:</span>
            <span class="c1">#   - Empty keys imply a null value, although they don&#39;t contain a null child.</span>
            <span class="c1">#   - Types are checked so bools aren&#39;t simplified to &quot;truthiness&quot; evaluations.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">is_empty_key</span><span class="p">())</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()</span>
                <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>  <span class="c1"># pylint: disable=unidiomatic-typecheck</span>
                <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">value</span>
            <span class="p">):</span>
                <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stack_path_to_str</span><span class="p">(</span><span class="n">path_stack</span><span class="p">))</span>

        <span class="n">traverse_all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">,</span> <span class="n">_find_value_paths</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">paths</span></div>


    <span class="c1">## General Convenience Functions ##</span>

<div class="viewcode-block" id="RecipeParser.is_multi_output">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.is_multi_output">[docs]</a>
    <span class="k">def</span> <span class="nf">is_multi_output</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicates if a recipe is a &quot;multiple output&quot; recipe.</span>
<span class="sd">        :returns: True if the recipe produces multiple outputs. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_value</span><span class="p">(</span><span class="s2">&quot;/outputs&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="RecipeParser.get_package_paths">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.get_package_paths">[docs]</a>
    <span class="k">def</span> <span class="nf">get_package_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience function that returns the locations of all &quot;outputs&quot; in the `/outputs` directory AND the root/</span>
<span class="sd">        top-level of the recipe file. Combined with a call to `get_value()` with a default value and a for loop, this</span>
<span class="sd">        should easily allow the calling code to handle editing/examining configurations found in:</span>
<span class="sd">          - &quot;Simple&quot; (non-multi-output) recipe files</span>
<span class="sd">          - Multi-output recipe files</span>
<span class="sd">          - Recipes that have both top-level and multi-output sections. An example can be found here:</span>
<span class="sd">              https://github.com/AnacondaRecipes/curl-feedstock/blob/master/recipe/meta.yaml</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">paths</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;/&quot;</span><span class="p">]</span>

        <span class="n">outputs</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;/outputs&quot;</span><span class="p">,</span> <span class="p">[]))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)):</span>
            <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;/outputs/</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">paths</span></div>


<div class="viewcode-block" id="RecipeParser.append_to_path">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.append_to_path">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">append_to_path</span><span class="p">(</span><span class="n">base_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">ext_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience function meant to be paired with `get_package_paths()` to generate extended paths. This handles</span>
<span class="sd">        issues that arise when concatenating paths that do or do not include a trailing/leading `/` character. Most</span>
<span class="sd">        notably, the root path `/` inherently contains a trailing `/`.</span>
<span class="sd">        :param base_path: Base path, provided by `get_package_paths()`</span>
<span class="sd">        :param ext_path: Path to append to the end of the `base_path`</span>
<span class="sd">        :returns: A normalized path constructed by the two provided paths.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure the base path always ends in a `/`</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">base_path</span><span class="p">:</span>
            <span class="n">base_path</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span>
        <span class="k">if</span> <span class="n">base_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;/&quot;</span><span class="p">:</span>
            <span class="n">base_path</span> <span class="o">+=</span> <span class="s2">&quot;/&quot;</span>
        <span class="c1"># Ensure the extended path never starts with a `/`</span>
        <span class="k">if</span> <span class="n">ext_path</span> <span class="ow">and</span> <span class="n">ext_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;/&quot;</span><span class="p">:</span>
            <span class="n">ext_path</span> <span class="o">=</span> <span class="n">ext_path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">base_path</span><span class="si">}{</span><span class="n">ext_path</span><span class="si">}</span><span class="s2">&quot;</span></div>


<div class="viewcode-block" id="RecipeParser.get_dependency_paths">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.get_dependency_paths">[docs]</a>
    <span class="k">def</span> <span class="nf">get_dependency_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience function that returns a list of all dependency lines in a recipe.</span>
<span class="sd">        :returns: A list of all paths in a recipe file that point to dependencies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">paths</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">req_sections</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;build&quot;</span><span class="p">,</span> <span class="s2">&quot;host&quot;</span><span class="p">,</span> <span class="s2">&quot;run&quot;</span><span class="p">,</span> <span class="s2">&quot;run_constrained&quot;</span><span class="p">]</span>

        <span class="c1"># Convenience function that reduces repeated logic between regular and multi-output recipes</span>
        <span class="k">def</span> <span class="nf">_scan_requirements</span><span class="p">(</span><span class="n">path_prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">req_sections</span><span class="p">:</span>
                <span class="n">section_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">path_prefix</span><span class="si">}</span><span class="s2">/requirements/</span><span class="si">{</span><span class="n">section</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="c1"># Relying on `get_value()` ensures that we will only examine literal values and ignore comments</span>
                <span class="c1"># in-between dependencies.</span>
                <span class="n">dependencies</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">section_path</span><span class="p">,</span> <span class="p">[]))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dependencies</span><span class="p">)):</span>
                    <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">section_path</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Scan for both multi-output and non-multi-output recipes. Here is an example of a recipe that has both:</span>
        <span class="c1">#   https://github.com/AnacondaRecipes/curl-feedstock/blob/master/recipe/meta.yaml</span>
        <span class="n">_scan_requirements</span><span class="p">()</span>

        <span class="n">outputs</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="n">JsonType</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;/outputs&quot;</span><span class="p">,</span> <span class="p">[]))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)):</span>
            <span class="n">_scan_requirements</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;/outputs/</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">paths</span></div>


    <span class="c1">## Jinja Variable Functions ##</span>

<div class="viewcode-block" id="RecipeParser.list_variables">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.list_variables">[docs]</a>
    <span class="k">def</span> <span class="nf">list_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns variables found in the recipe, sorted by first appearance.</span>
<span class="sd">        :returns: List of variables found in the recipe.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vars_tbl</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>


<div class="viewcode-block" id="RecipeParser.contains_variable">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.contains_variable">[docs]</a>
    <span class="k">def</span> <span class="nf">contains_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if a variable is set in this recipe.</span>
<span class="sd">        :param var: Variable to check for.</span>
<span class="sd">        :returns: True if a variable name is found in this recipe. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars_tbl</span></div>


<div class="viewcode-block" id="RecipeParser.get_variable">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.get_variable">[docs]</a>
    <span class="k">def</span> <span class="nf">get_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="n">JsonType</span> <span class="o">|</span> <span class="n">SentinelType</span> <span class="o">=</span> <span class="n">_sentinel</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">JsonType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the value of a variable set in the recipe. If specified, a default value will be returned if the</span>
<span class="sd">        variable name is not found.</span>
<span class="sd">        :param var: Variable of interest check for.</span>
<span class="sd">        :param default: (Optional) If the value is not found, return this value instead.</span>
<span class="sd">        :raises KeyError: If the value is not found AND no default is specified</span>
<span class="sd">        :returns: The value (or specified default value if not found) of the variable name provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars_tbl</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">default</span> <span class="o">==</span> <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_sentinel</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="n">SentinelType</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">KeyError</span>
            <span class="k">return</span> <span class="n">default</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars_tbl</span><span class="p">[</span><span class="n">var</span><span class="p">]</span></div>


<div class="viewcode-block" id="RecipeParser.set_variable">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.set_variable">[docs]</a>
    <span class="k">def</span> <span class="nf">set_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">JsonType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds or changes an existing Jinja variable.</span>
<span class="sd">        :param var: Variable to modify</span>
<span class="sd">        :param value: Value to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vars_tbl</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_modified</span> <span class="o">=</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="RecipeParser.del_variable">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.del_variable">[docs]</a>
    <span class="k">def</span> <span class="nf">del_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a variable from the project. If one is not found, no changes are made.</span>
<span class="sd">        :param var: Variable to delete</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars_tbl</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars_tbl</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_modified</span> <span class="o">=</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="RecipeParser.get_variable_references">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.get_variable_references">[docs]</a>
    <span class="k">def</span> <span class="nf">get_variable_references</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of paths that use particular variables.</span>
<span class="sd">        :param var: Variable of interest</span>
<span class="sd">        :returns: List of paths that use a variable, sorted by first appearance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars_tbl</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">path_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># The regular expression between the braces is very forgiving to match JINJA expressions like</span>
        <span class="c1"># `{{ name | lower }}`</span>
        <span class="k">def</span> <span class="nf">_init_re</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
            <span class="k">match</span> <span class="bp">self</span><span class="o">.</span><span class="n">_schema_version</span><span class="p">:</span>
                <span class="k">case</span> <span class="n">SchemaVersion</span><span class="o">.</span><span class="n">V0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;{{.*&quot;</span> <span class="o">+</span> <span class="n">var</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;.*}}&quot;</span><span class="p">)</span>
                <span class="k">case</span> <span class="n">SchemaVersion</span><span class="o">.</span><span class="n">V1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\${{.*&quot;</span> <span class="o">+</span> <span class="n">var</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;.*}}&quot;</span><span class="p">)</span>

        <span class="n">var_re</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">_init_re</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">_collect_var_refs</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">StrStack</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Variables can only be found inside string values.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">var_re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
                <span class="n">path_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stack_path_to_str</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>

        <span class="n">traverse_all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">,</span> <span class="n">_collect_var_refs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dedupe_and_preserve_order</span><span class="p">(</span><span class="n">path_list</span><span class="p">)</span></div>


    <span class="c1">## Selector Functions ##</span>

<div class="viewcode-block" id="RecipeParser.list_selectors">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.list_selectors">[docs]</a>
    <span class="k">def</span> <span class="nf">list_selectors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns selectors found in the recipe, sorted by first appearance.</span>
<span class="sd">        :returns: List of selectors found in the recipe.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_selector_tbl</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>


<div class="viewcode-block" id="RecipeParser.contains_selector">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.contains_selector">[docs]</a>
    <span class="k">def</span> <span class="nf">contains_selector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selector</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if a selector expression is present in this recipe.</span>
<span class="sd">        :param selector: Selector to check for.</span>
<span class="sd">        :returns: True if a selector is found in this recipe. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">selector</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selector_tbl</span></div>


<div class="viewcode-block" id="RecipeParser.get_selector_paths">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.get_selector_paths">[docs]</a>
    <span class="k">def</span> <span class="nf">get_selector_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selector</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a selector (including the surrounding brackets), provide a list of paths in the parse tree that use that</span>
<span class="sd">        selector.</span>

<span class="sd">        Selector paths will be ordered by the line they appear on in the file.</span>

<span class="sd">        :param selector: Selector of interest.</span>
<span class="sd">        :returns: A list of all known paths that use a particular selector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We return a tuple so that caller doesn&#39;t accidentally modify a private member variable.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains_selector</span><span class="p">(</span><span class="n">selector</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">path_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">path_stack</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selector_tbl</span><span class="p">[</span><span class="n">selector</span><span class="p">]:</span>
            <span class="n">path_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stack_path_to_str</span><span class="p">(</span><span class="n">path_stack</span><span class="o">.</span><span class="n">path</span><span class="p">))</span>
        <span class="c1"># The list should be de-duped and maintain order. Duplications occur when key-value pairings mean a selector</span>
        <span class="c1"># occurs on two nodes with the same path.</span>
        <span class="c1">#</span>
        <span class="c1"># For example:</span>
        <span class="c1">#   skip: True  # [unix]</span>
        <span class="c1"># The nodes for both `skip` and `True` contain the comment `[unix]`</span>
        <span class="k">return</span> <span class="n">dedupe_and_preserve_order</span><span class="p">(</span><span class="n">path_list</span><span class="p">)</span></div>


<div class="viewcode-block" id="RecipeParser.contains_selector_at_path">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.contains_selector_at_path">[docs]</a>
    <span class="k">def</span> <span class="nf">contains_selector_at_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a path, determine if a selector exists on that line.</span>
<span class="sd">        :param path: Target path</span>
<span class="sd">        :returns: True if the selector exists at that path. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path_stack</span> <span class="o">=</span> <span class="n">str_to_stack_path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">,</span> <span class="n">path_stack</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">Regex</span><span class="o">.</span><span class="n">SELECTOR</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">comment</span><span class="p">))</span></div>


<div class="viewcode-block" id="RecipeParser.get_selector_at_path">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.get_selector_at_path">[docs]</a>
    <span class="k">def</span> <span class="nf">get_selector_at_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">SentinelType</span> <span class="o">=</span> <span class="n">_sentinel</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a path, return the selector that exists on that line.</span>
<span class="sd">        :param path: Target path</span>
<span class="sd">        :param default: (Optional) Default value to use if no selector is found.</span>
<span class="sd">        :raises KeyError: If a selector is not found on the provided path AND no default has been specified.</span>
<span class="sd">        :raises ValueError: If the default selector provided is malformed</span>
<span class="sd">        :returns: Selector on the path provided</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path_stack</span> <span class="o">=</span> <span class="n">str_to_stack_path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">,</span> <span class="n">path_stack</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Path not found: </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">search_results</span> <span class="o">=</span> <span class="n">Regex</span><span class="o">.</span><span class="n">SELECTOR</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">comment</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">search_results</span><span class="p">:</span>
            <span class="c1"># Use `default` case</span>
            <span class="k">if</span> <span class="n">default</span> <span class="o">!=</span> <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_sentinel</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="n">SentinelType</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">Regex</span><span class="o">.</span><span class="n">SELECTOR</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">default</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid selector provided: </span><span class="si">{</span><span class="n">default</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">default</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Selector not found at path: </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">search_results</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="RecipeParser.add_selector">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.add_selector">[docs]</a>
    <span class="k">def</span> <span class="nf">add_selector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">selector</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="n">SelectorConflictMode</span> <span class="o">=</span> <span class="n">SelectorConflictMode</span><span class="o">.</span><span class="n">REPLACE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a path, add a selector (include the surrounding brackets) to the line denoted by path.</span>
<span class="sd">        :param path: Path to add a selector to</span>
<span class="sd">        :param selector: Selector statement to add</span>
<span class="sd">        :param mode: (Optional) Indicates how to handle a conflict if a selector already exists at this path.</span>
<span class="sd">        :raises KeyError: If the path provided is not found</span>
<span class="sd">        :raises ValueError: If the selector provided is malformed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path_stack</span> <span class="o">=</span> <span class="n">str_to_stack_path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">,</span> <span class="n">path_stack</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Path not found: </span><span class="si">{</span><span class="n">path</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">Regex</span><span class="o">.</span><span class="n">SELECTOR</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">selector</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid selector provided: </span><span class="si">{</span><span class="n">selector</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Helper function that extracts the outer set of []&#39;s in a selector</span>
        <span class="k">def</span> <span class="nf">_extract_selector</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">comment</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">old_selector_found</span> <span class="o">=</span> <span class="n">Regex</span><span class="o">.</span><span class="n">SELECTOR</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">comment</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">comment</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">SelectorConflictMode</span><span class="o">.</span><span class="n">REPLACE</span><span class="p">:</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;# </span><span class="si">{</span><span class="n">selector</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="c1"># &quot;Append&quot; to existing selectors</span>
        <span class="k">elif</span> <span class="n">old_selector_found</span><span class="p">:</span>
            <span class="n">logic_op</span> <span class="o">=</span> <span class="s2">&quot;and&quot;</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">SelectorConflictMode</span><span class="o">.</span><span class="n">AND</span> <span class="k">else</span> <span class="s2">&quot;or&quot;</span>
            <span class="n">old_selector</span> <span class="o">=</span> <span class="n">_extract_selector</span><span class="p">(</span><span class="n">old_selector_found</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
            <span class="n">new_selector</span> <span class="o">=</span> <span class="n">_extract_selector</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;# [</span><span class="si">{</span><span class="n">old_selector</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">logic_op</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">new_selector</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="c1"># If the comment is not a selector, put the selector first, then append the comment.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Strip the existing comment of it&#39;s leading `#` symbol</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;# </span><span class="si">{</span><span class="n">selector</span><span class="si">}</span><span class="s2"> &quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">comment</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="n">node</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="n">comment</span>
        <span class="c1"># Some lines of YAML correspond to multiple nodes. For consistency, we need to ensure that comments are</span>
        <span class="c1"># duplicate across all nodes on a line.</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_single_key</span><span class="p">():</span>
            <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="n">comment</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_rebuild_selectors</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_modified</span> <span class="o">=</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="RecipeParser.remove_selector">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.remove_selector">[docs]</a>
    <span class="k">def</span> <span class="nf">remove_selector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a path, remove a selector to the line denoted by path.</span>
<span class="sd">        - If a selector does not exist, nothing happens.</span>
<span class="sd">        - If a comment exists after the selector, keep it, discard the selector.</span>
<span class="sd">        :param path: Path to add a selector to</span>
<span class="sd">        :raises KeyError: If the path provided is not found</span>
<span class="sd">        :returns: If found, the selector removed (includes surrounding brackets). Otherwise, returns None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path_stack</span> <span class="o">=</span> <span class="n">str_to_stack_path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">,</span> <span class="n">path_stack</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Path not found: </span><span class="si">{</span><span class="n">path</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">search_results</span> <span class="o">=</span> <span class="n">Regex</span><span class="o">.</span><span class="n">SELECTOR</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">comment</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">search_results</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">selector</span> <span class="o">=</span> <span class="n">search_results</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">comment</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">comment</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">selector</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="c1"># Sanitize potential edge-case scenarios after a removal</span>
        <span class="n">comment</span> <span class="o">=</span> <span class="n">comment</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;#  &quot;</span><span class="p">,</span> <span class="s2">&quot;# &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;# # &quot;</span><span class="p">,</span> <span class="s2">&quot;# &quot;</span><span class="p">)</span>
        <span class="c1"># Detect and remove empty comments. Other comments should remain intact.</span>
        <span class="k">if</span> <span class="n">comment</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;#&quot;</span><span class="p">:</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="n">node</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="n">comment</span>
        <span class="c1"># Some lines of YAML correspond to multiple nodes. For consistency, we need to ensure that comments are</span>
        <span class="c1"># duplicate across all nodes on a line.</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_single_key</span><span class="p">():</span>
            <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="n">comment</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_rebuild_selectors</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_modified</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">selector</span></div>


    <span class="c1">## Comment Functions ##</span>

<div class="viewcode-block" id="RecipeParser.get_comments_table">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.get_comments_table">[docs]</a>
    <span class="k">def</span> <span class="nf">get_comments_table</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary containing the location of every comment mapped to the value of the comment.</span>
<span class="sd">        NOTE:</span>
<span class="sd">            - Selectors are not considered to be comments.</span>
<span class="sd">            - Lines containing only comments are currently not addressable by our pathing scheme, so they are omitted.</span>
<span class="sd">              For our current purposes (of upgrading the recipe format) this should be fine. Non-addressable values</span>
<span class="sd">              should be less likely to be removed from patch operations.</span>
<span class="sd">        :returns: List of paths where comments can be found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">comments_tbl</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">_track_comments</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">path_stack</span><span class="p">:</span> <span class="n">StrStack</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_comment</span><span class="p">()</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">comment</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">comment</span>
            <span class="c1"># Handle comments found alongside a selector</span>
            <span class="k">if</span> <span class="n">Regex</span><span class="o">.</span><span class="n">SELECTOR</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">comment</span><span class="p">):</span>
                <span class="n">comment</span> <span class="o">=</span> <span class="n">Regex</span><span class="o">.</span><span class="n">SELECTOR</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">comment</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="c1"># Sanitize common artifacts left from removing the selector</span>
                <span class="n">comment</span> <span class="o">=</span> <span class="n">comment</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;#  # &quot;</span><span class="p">,</span> <span class="s2">&quot;# &quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;#  &quot;</span><span class="p">,</span> <span class="s2">&quot;# &quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

                <span class="c1"># Reject selector-only comments</span>
                <span class="k">if</span> <span class="n">comment</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;#&quot;</span><span class="p">}:</span>
                    <span class="k">return</span>
                <span class="k">if</span> <span class="n">comment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;#&quot;</span><span class="p">:</span>
                    <span class="n">comment</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;# </span><span class="si">{</span><span class="n">comment</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="n">path</span> <span class="o">=</span> <span class="n">stack_path_to_str</span><span class="p">(</span><span class="n">path_stack</span><span class="p">)</span>
            <span class="n">comments_tbl</span><span class="p">[</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="n">comment</span>

        <span class="n">traverse_all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">,</span> <span class="n">_track_comments</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">comments_tbl</span></div>


<div class="viewcode-block" id="RecipeParser.add_comment">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.add_comment">[docs]</a>
    <span class="k">def</span> <span class="nf">add_comment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">comment</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a comment to an existing path. If a comment exists, replaces the existing comment. If a selector exists,</span>
<span class="sd">        comment is appended after the selector component of the comment.</span>
<span class="sd">        :param path: Target path to add a comment to</span>
<span class="sd">        :param comment: Comment to add</span>
<span class="sd">        :raises KeyError: If the path provided is not found</span>
<span class="sd">        :raises ValueError: If the comment provided is a selector, the empty string, or consists of only whitespace</span>
<span class="sd">            characters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">comment</span> <span class="o">=</span> <span class="n">comment</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">comment</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Comments cannot consist only of whitespace characters&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">Regex</span><span class="o">.</span><span class="n">SELECTOR</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">comment</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Selectors can not be submitted as comments: </span><span class="si">{</span><span class="n">comment</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">node</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">,</span> <span class="n">str_to_stack_path</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Path not found: </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">search_results</span> <span class="o">=</span> <span class="n">Regex</span><span class="o">.</span><span class="n">SELECTOR</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">comment</span><span class="p">)</span>
        <span class="c1"># If a selector is present, append the selector.</span>
        <span class="k">if</span> <span class="n">search_results</span><span class="p">:</span>
            <span class="n">selector</span> <span class="o">=</span> <span class="n">search_results</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">comment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;#&quot;</span><span class="p">:</span>
                <span class="n">comment</span> <span class="o">=</span> <span class="n">comment</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;# </span><span class="si">{</span><span class="n">selector</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">comment</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># Prepend a `#` if it is missing</span>
        <span class="k">if</span> <span class="n">comment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;#&quot;</span><span class="p">:</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;# </span><span class="si">{</span><span class="n">comment</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">node</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="n">comment</span>
        <span class="c1"># Comments for &quot;single key&quot; nodes apply to both the parent and child. This is because such parent nodes render</span>
        <span class="c1"># on the same line as their children.</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_single_key</span><span class="p">():</span>
            <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="n">comment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_modified</span> <span class="o">=</span> <span class="kc">True</span></div>


    <span class="c1">## YAML Patching Functions ##</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_valid_patch_node</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">node_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TypeGuard</span><span class="p">[</span><span class="n">Node</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicates if the target node to perform a patch operation against is a valid node. This is based on the RFC spec</span>
<span class="sd">        for JSON patching paths.</span>
<span class="sd">        :param node: Target node to validate</span>
<span class="sd">        :param node_idx: If the caller is evaluating that a list member, exists, this is the VIRTUAL index into that</span>
<span class="sd">            list. Otherwise this value should be less than 0.</span>
<span class="sd">        :returns: True if the node can be patched. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Path not found</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Leaf nodes contain values and not path information. Paths should not be made that access leaf nodes, with the</span>
        <span class="c1"># exception of members of a list and keys. Making such a path violates the RFC.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">list_member_flag</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">key_flag</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">node_idx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Check the bounds if the target requires the use of an index, remembering to use the virtual look-up table.</span>
            <span class="n">idx_map</span> <span class="o">=</span> <span class="n">remap_child_indices_virt_to_phys</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node_idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">node_idx</span> <span class="o">&gt;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx_map</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># You cannot use the list access feature to access non-lists</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">idx_map</span><span class="p">[</span><span class="n">node_idx</span><span class="p">]]</span><span class="o">.</span><span class="n">list_member_flag</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_patch_add_find_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_stack</span><span class="p">:</span> <span class="n">StrStack</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the target node of an `add()` operation, along with some supporting information.</span>

<span class="sd">        This function does not modify the parse tree.</span>
<span class="sd">        :param path_stack: Path that describes a location in the tree, as a list, treated like a stack.</span>
<span class="sd">        :returns: A tuple containing: - The target node, if found (or the parent node if the target is a list member) -</span>
<span class="sd">            The index of a node if the target is a list member - An additional path that needs to be created, if</span>
<span class="sd">            applicable - A flag indicating if the new data will be appended to a list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">INVALID_IDX</span><span class="p">,</span> <span class="n">INVALID_IDX</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="kc">False</span>

        <span class="c1"># Special case that only applies to `add`. The `-` character indicates the new element can be added to the end</span>
        <span class="c1"># of the list.</span>
        <span class="n">append_to_list</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">path_stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
            <span class="n">path_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">append_to_list</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">path_stack_copy</span> <span class="o">=</span> <span class="n">path_stack</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">virt_idx</span><span class="p">,</span> <span class="n">phys_idx</span> <span class="o">=</span> <span class="n">traverse_with_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">,</span> <span class="n">path_stack</span><span class="p">)</span>
        <span class="c1"># Attempt to run a second time, if no node is found. As per the RFC, the containing object/list must exist. That</span>
        <span class="c1"># allows us to create only 1 level in the path.</span>
        <span class="n">path_to_create</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">path_to_create</span> <span class="o">=</span> <span class="n">path_stack_copy</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">virt_idx</span><span class="p">,</span> <span class="n">phys_idx</span> <span class="o">=</span> <span class="n">traverse_with_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">,</span> <span class="n">path_stack_copy</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">node</span><span class="p">,</span> <span class="n">virt_idx</span><span class="p">,</span> <span class="n">phys_idx</span><span class="p">,</span> <span class="n">path_to_create</span><span class="p">,</span> <span class="n">append_to_list</span>

    <span class="k">def</span> <span class="nf">_patch_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_stack</span><span class="p">:</span> <span class="n">StrStack</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">JsonType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a JSON patch `add` operation.</span>
<span class="sd">        :param path_stack: Path that describes a location in the tree, as a list, treated like a stack.</span>
<span class="sd">        :param value: Value to add.</span>
<span class="sd">        :returns: True if the operation was successful. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE from the RFC:</span>
        <span class="c1">#   Because this operation is designed to add to existing objects and arrays, its target location will often</span>
        <span class="c1">#   not exist...However, the object itself or an array containing it does need to exist</span>
        <span class="c1"># In other words, the patch op will, at most, create 1 new path level. In addition, that also implies that</span>
        <span class="c1"># trying to append to an existing list only applies if the append operator is at the end of the list.</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">virt_idx</span><span class="p">,</span> <span class="n">phys_idx</span><span class="p">,</span> <span class="n">path_to_create</span><span class="p">,</span> <span class="n">append_to_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patch_add_find_target</span><span class="p">(</span><span class="n">path_stack</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_is_valid_patch_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">virt_idx</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># If we couldn&#39;t find 1 level in the path, ensure that we re-insert that as the &quot;root&quot; of the sub-tree we are</span>
        <span class="c1"># about to create.</span>
        <span class="k">if</span> <span class="n">path_to_create</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">{</span><span class="n">path_to_create</span><span class="p">:</span> <span class="n">value</span><span class="p">}</span>

        <span class="n">new_children</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_generate_subtree</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="c1"># Mark children as list members if they are list members</span>
        <span class="k">if</span> <span class="n">append_to_list</span> <span class="ow">or</span> <span class="n">phys_idx</span> <span class="o">&gt;</span> <span class="n">INVALID_IDX</span><span class="p">:</span>
            <span class="c1"># Adding an object to a list requires the children to be wrapped in a collection node</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">PRIMITIVES_TUPLE</span><span class="p">):</span>
                <span class="n">new_children</span> <span class="o">=</span> <span class="p">[</span><span class="n">Node</span><span class="p">(</span><span class="n">list_member_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="n">new_children</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">new_children</span><span class="p">:</span>
                    <span class="n">child</span><span class="o">.</span><span class="n">list_member_flag</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Insert members if an index is specified. Otherwise, extend the list of child nodes from the existing list.</span>
        <span class="k">if</span> <span class="n">phys_idx</span> <span class="o">&gt;</span> <span class="n">INVALID_IDX</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">phys_idx</span><span class="p">:</span><span class="n">phys_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_children</span>
        <span class="c1"># Extend the list of children if we&#39;re appending or adding a new key.</span>
        <span class="k">elif</span> <span class="n">append_to_list</span> <span class="ow">or</span> <span class="n">path_to_create</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_children</span><span class="p">)</span>
        <span class="c1"># NOTE from the RFC: &quot;If the member already exists, it is replaced by the specified value.&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">new_children</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_patch_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_stack</span><span class="p">:</span> <span class="n">StrStack</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a JSON patch `remove` operation.</span>
<span class="sd">        :param path_stack: Path that describes a location in the tree, as a list, treated like a stack.</span>
<span class="sd">        :returns: True if the operation was successful. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Removal in all scenarios requires targeting the parent node.</span>
        <span class="n">node_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">path_stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">path_stack</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># `traverse()` is destructive to the stack, so make a copy for the second traversal call.</span>
        <span class="n">path_stack_copy</span> <span class="o">=</span> <span class="n">path_stack</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">node_to_rm</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">,</span> <span class="n">path_stack</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_is_valid_patch_node</span><span class="p">(</span><span class="n">node_to_rm</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">path_stack_copy</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">,</span> <span class="n">path_stack_copy</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_is_valid_patch_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node_idx</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">node_idx</span> <span class="o">&gt;</span> <span class="n">INVALID_IDX</span><span class="p">:</span>
            <span class="c1"># Pop the &quot;physical&quot; index, not the &quot;virtual&quot; one to ensure comments have been accounted for.</span>
            <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">remap_child_indices_virt_to_phys</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)[</span><span class="n">node_idx</span><span class="p">])</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># In all other cases, the node to be removed must be found before eviction</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">node_to_rm</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_patch_replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_stack</span><span class="p">:</span> <span class="n">StrStack</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">JsonType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a JSON patch `replace` operation.</span>
<span class="sd">        :param path_stack: Path that describes a location in the tree, as a list, treated like a stack.</span>
<span class="sd">        :param value: Value to update with.</span>
<span class="sd">        :returns: True if the operation was successful. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">virt_idx</span><span class="p">,</span> <span class="n">phys_idx</span> <span class="o">=</span> <span class="n">traverse_with_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">,</span> <span class="n">path_stack</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_is_valid_patch_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">virt_idx</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">new_children</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_generate_subtree</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="c1"># Lists inject all children at the target position.</span>
        <span class="k">if</span> <span class="n">phys_idx</span> <span class="o">&gt;</span> <span class="n">INVALID_IDX</span><span class="p">:</span>
            <span class="c1"># Adding an object to a list requires the children to be wrapped in a collection node</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">PRIMITIVES_TUPLE</span><span class="p">):</span>
                <span class="n">new_children</span> <span class="o">=</span> <span class="p">[</span><span class="n">Node</span><span class="p">(</span><span class="n">list_member_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="n">new_children</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Ensure all children are marked as list members</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">new_children</span><span class="p">:</span>
                    <span class="n">child</span><span class="o">.</span><span class="n">list_member_flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">phys_idx</span><span class="p">:</span><span class="n">phys_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_children</span>
            <span class="c1"># Evict the old child, which is now behind the new children</span>
            <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">phys_idx</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_children</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># Leafs that represent values/paths of values can evict all children, and be replaced with new children, derived</span>
        <span class="c1"># from a new tree of values.</span>
        <span class="n">node</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">new_children</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_patch_move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_stack</span><span class="p">:</span> <span class="n">StrStack</span><span class="p">,</span> <span class="n">value_from</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a JSON patch `add` operation.</span>
<span class="sd">        :param path_stack: Path that describes a location in the tree, as a list, treated like a stack.</span>
<span class="sd">        :param value_from: The &quot;from&quot; value in the JSON payload, i.e. the path the value originates from.</span>
<span class="sd">        :returns: True if the operation was successful. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE from the RFC:</span>
        <span class="c1">#   This operation is functionally identical to a &quot;remove&quot; operation on the &quot;from&quot; location, followed</span>
        <span class="c1">#   immediately by an &quot;add&quot; operation at the target location with the value that was just removed.</span>
        <span class="c1"># So to save on development and maintenance, that is how this op is written.</span>
        <span class="n">original_value</span><span class="p">:</span> <span class="n">JsonType</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">original_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">value_from</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Validate that `add` will succeed before we `remove` anything</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">virt_idx</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patch_add_find_target</span><span class="p">(</span><span class="n">path_stack</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_is_valid_patch_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">virt_idx</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patch_remove</span><span class="p">(</span><span class="n">str_to_stack_path</span><span class="p">(</span><span class="n">value_from</span><span class="p">))</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patch_add</span><span class="p">(</span><span class="n">path_stack</span><span class="p">,</span> <span class="n">original_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_patch_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_stack</span><span class="p">:</span> <span class="n">StrStack</span><span class="p">,</span> <span class="n">value_from</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a JSON patch `add` operation.</span>
<span class="sd">        :param path_stack: Path that describes a location in the tree, as a list, treated like a stack.</span>
<span class="sd">        :param value_from: The &quot;from&quot; value in the JSON payload, i.e. the path the value originates from.</span>
<span class="sd">        :returns: True if the operation was successful. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE from the RFC:</span>
        <span class="c1">#   This operation is functionally identical to an &quot;add&quot; operation at the target location using the value</span>
        <span class="c1">#   specified in the &quot;from&quot; member.</span>
        <span class="c1"># So to save on development and maintenance, that is how this op is written.</span>
        <span class="n">original_value</span><span class="p">:</span> <span class="n">JsonType</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">original_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">value_from</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patch_add</span><span class="p">(</span><span class="n">path_stack</span><span class="p">,</span> <span class="n">original_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_patch_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">JsonType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a JSON patch `test` operation.</span>
<span class="sd">        :param path: Path as a string. Useful for invoking public class members.</span>
<span class="sd">        :param value: Value to evaluate against.</span>
<span class="sd">        :returns: True if the target value is equal to the provided value. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="n">value</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># Path not found</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_call_patch_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">patch</span><span class="p">:</span> <span class="n">JsonPatchType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Switching function that calls the appropriate JSON patch operation.</span>
<span class="sd">        :param op: Patch operation, pre-sanitized.</span>
<span class="sd">        :param path: Path as a string.</span>
<span class="sd">        :param patch: The original JSON patch. This is passed to conditionally provide extra arguments, per op.</span>
<span class="sd">        :returns: True if the patch was successful. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path_stack</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="n">StrStack</span><span class="p">]</span> <span class="o">=</span> <span class="n">str_to_stack_path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="c1"># NOTE: The `remove` op has no `value` or `from` field to pass in, so it is executed first.</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;remove&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patch_remove</span><span class="p">(</span><span class="n">path_stack</span><span class="p">)</span>

        <span class="c1"># The supplemental field name is determined by the operation type.</span>
        <span class="n">value_from</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;from&quot;</span> <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">RecipeParser</span><span class="o">.</span><span class="n">_patch_ops_requiring_from</span> <span class="k">else</span> <span class="s2">&quot;value&quot;</span>
        <span class="n">patch_data</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="n">JsonType</span> <span class="o">|</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">patch</span><span class="p">[</span><span class="n">value_from</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;add&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patch_add</span><span class="p">(</span><span class="n">path_stack</span><span class="p">,</span> <span class="n">patch_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;replace&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patch_replace</span><span class="p">(</span><span class="n">path_stack</span><span class="p">,</span> <span class="n">patch_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;move&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patch_move</span><span class="p">(</span><span class="n">path_stack</span><span class="p">,</span> <span class="n">cast</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">patch_data</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;copy&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patch_copy</span><span class="p">(</span><span class="n">path_stack</span><span class="p">,</span> <span class="n">cast</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">patch_data</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;test&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patch_test</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">patch_data</span><span class="p">)</span>

        <span class="c1"># This should be unreachable but is kept for completeness.</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="RecipeParser.patch">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.patch">[docs]</a>
    <span class="k">def</span> <span class="nf">patch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">patch</span><span class="p">:</span> <span class="n">JsonPatchType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a JSON-patch object, perform a patch operation.</span>

<span class="sd">        Modifications from RFC 6902</span>
<span class="sd">          - We&#39;re using a Jinja-formatted YAML file, not JSON</span>
<span class="sd">          - To modify comments, specify the `path` AND `comment`</span>

<span class="sd">        :param patch: JSON-patch payload to operate with.</span>
<span class="sd">        :raises JsonPatchValidationException: If the JSON-patch payload does not conform to our schema/spec.</span>
<span class="sd">        :returns: If the calling code attempts to perform the `test` operation, this indicates the return value of the</span>
<span class="sd">            `test` request. In other words, if `value` matches the target variable, return True. False otherwise. For</span>
<span class="sd">            all other operations, this indicates if the operation was successful.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate the patch schema</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">schema_validate</span><span class="p">(</span><span class="n">patch</span><span class="p">,</span> <span class="n">JSON_PATCH_SCHEMA</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">JsonPatchValidationException</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="n">path</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">patch</span><span class="p">[</span><span class="s2">&quot;path&quot;</span><span class="p">])</span>

        <span class="c1"># All RFC ops are supported, so the JSON schema validation checks will prevent us from getting this far, if</span>
        <span class="c1"># there is an issue.</span>
        <span class="n">op</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">patch</span><span class="p">[</span><span class="s2">&quot;op&quot;</span><span class="p">])</span>

        <span class="c1"># A no-op move is silly, but we might as well make it efficient AND ensure a no-op move doesn&#39;t corrupt our</span>
        <span class="c1"># modification flag.</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;move&quot;</span> <span class="ow">and</span> <span class="n">path</span> <span class="o">==</span> <span class="n">patch</span><span class="p">[</span><span class="s2">&quot;from&quot;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># Both versions of the path are sent over so that the op can easily use both private and public functions</span>
        <span class="c1"># (without incurring even more conversions between path types).</span>
        <span class="n">is_successful</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_patch_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">patch</span><span class="p">)</span>

        <span class="c1"># Update the selector table and modified flag, if the operation succeeded.</span>
        <span class="k">if</span> <span class="n">is_successful</span> <span class="ow">and</span> <span class="n">op</span> <span class="o">!=</span> <span class="s2">&quot;test&quot;</span><span class="p">:</span>
            <span class="c1"># TODO this is not the most efficient way to update the selector table, but for now, it works.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rebuild_selectors</span><span class="p">()</span>
            <span class="c1"># TODO technically this doesn&#39;t handle a no-op.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_modified</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">is_successful</span></div>


<div class="viewcode-block" id="RecipeParser.search">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.search">[docs]</a>
    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">include_comment</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a regex string, return the list of paths that match the regex.</span>
<span class="sd">        NOTE: This function only searches against primitive values. All variables and selectors can be fully provided by</span>
<span class="sd">              using their respective `list_*()` functions.</span>

<span class="sd">        :param regex: Regular expression to match with</span>
<span class="sd">        :param include_comment: (Optional) If set to `True`, this function will execute the regular expression on values</span>
<span class="sd">            WITH their comments provided. For example: `42  # This is a comment`</span>
<span class="sd">        :returns: Returns a list of paths where the matched value was found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">re_obj</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>
        <span class="n">paths</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">_search_paths</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span> <span class="n">path_stack</span><span class="p">:</span> <span class="n">StrStack</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">stringify_yaml</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">include_comment</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">comment</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="si">}{</span><span class="n">TAB_AS_SPACES</span><span class="si">}{</span><span class="n">node</span><span class="o">.</span><span class="n">comment</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">()</span> <span class="ow">and</span> <span class="n">re_obj</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stack_path_to_str</span><span class="p">(</span><span class="n">path_stack</span><span class="p">))</span>

        <span class="n">traverse_all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="p">,</span> <span class="n">_search_paths</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">paths</span></div>


<div class="viewcode-block" id="RecipeParser.search_and_patch">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.search_and_patch">[docs]</a>
    <span class="k">def</span> <span class="nf">search_and_patch</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">regex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">patch</span><span class="p">:</span> <span class="n">JsonPatchType</span><span class="p">,</span> <span class="n">include_comment</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a regex string and a JSON patch, apply the patch to any values that match the search expression.</span>
<span class="sd">        :param regex: Regular expression to match with</span>
<span class="sd">        :param patch: JSON patch to perform. NOTE: The `path` field will be replaced with the path(s) found, so it does</span>
<span class="sd">            not need to be provided.</span>
<span class="sd">        :param include_comment: (Optional) If set to `True`, this function will execute the regular expression on values</span>
<span class="sd">            WITH their comments provided. For example: `42  # This is a comment`</span>
<span class="sd">        :returns: Returns a list of paths where the matched value was found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="n">include_comment</span><span class="p">)</span>
        <span class="n">summation</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
            <span class="n">patch</span><span class="p">[</span><span class="s2">&quot;path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span>
            <span class="n">summation</span> <span class="o">=</span> <span class="n">summation</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">summation</span></div>


<div class="viewcode-block" id="RecipeParser.diff">
<a class="viewcode-back" href="../../../conda_recipe_manager.parser.html#conda_recipe_manager.parser.recipe_parser.RecipeParser.diff">[docs]</a>
    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a git-like-styled diff of the current recipe state with original state of the recipe. Useful for</span>
<span class="sd">        debugging and providing users with some feedback.</span>
<span class="sd">        :returns: User-friendly displayable string that represents notifications made to the recipe.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_modified</span><span class="p">():</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>
        <span class="c1"># Utilize `difflib` to lower maintenance overhead.</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">difflib</span><span class="o">.</span><span class="n">unified_diff</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_init_content</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">render</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(),</span> <span class="n">fromfile</span><span class="o">=</span><span class="s2">&quot;original&quot;</span><span class="p">,</span> <span class="n">tofile</span><span class="o">=</span><span class="s2">&quot;current&quot;</span>
            <span class="p">)</span>
        <span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

</body>
</html>
